package simple;

import java.util.*;
import java_cup.runtime.*;

// =====================================================================
// SECTION 1: PREAMBLE & IMPORTS
// =====================================================================

// Java code that goes inside the generated parser class
parser code {:
    // You can add helper methods or fields here if needed.
:};

// =====================================================================
// SECTION 2: TERMINAL & NON-TERMINAL DECLARATIONS
// =====================================================================

// --- TERMINALS (Tokens from the lexer) ---
// These names MUST match what you use in the JFlex file.
terminal LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE, COMMA, SEMICOLON;
terminal ASSIGN, EQ, LT, GT, PLUS, MINUS, STAR, SLASH;
terminal INT, BOOLEAN, IF, ELSE, WHILE, RETURN, TRUE, FALSE;

// Terminals with values (like numbers and identifiers) need a type.
terminal String IDENTIFIER;
terminal Integer INTEGER_LIT;

// --- NON-TERMINALS (Grammar rules) ---
// We must declare the type of object that each grammar rule will return.
nonterminal ProgramNode program;
nonterminal List<FuncDef> func_definitions;
nonterminal FuncDef func_definition;
nonterminal List<VarDecl> params;
nonterminal List<Stmt> stmts;
nonterminal Stmt stmt;
nonterminal BlockStmt block;
nonterminal List<VarDecl> declarations;
nonterminal VarDecl declaration;
nonterminal Type type;
nonterminal List<Expr> args;

nonterminal Expr expr;
nonterminal Expr simple_expr; // For handling precedence

// =====================================================================
// SECTION 3: PRECEDENCE & ASSOCIATIVITY
// =====================================================================

// Defines operator precedence, from lowest to highest.
precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left STAR, SLASH;

// =====================================================================
// SECTION 4: THE GRAMMAR RULES
// =====================================================================

program ::= func_definitions:fns stmt:main
    {: RESULT = new ProgramNode(fns, main); :};

func_definitions ::= func_definitions:list func_definition:fd
    {: list.add(fd); RESULT = list; :}
    | /* empty */
    {: RESULT = new ArrayList<FuncDef>(); :};

func_definition ::= type:t IDENTIFIER:name LEFT_PAREN params:p RIGHT_PAREN stmt:body
    {: RESULT = new FuncDef(name, p, body); :};

params ::= params:list COMMA declaration:d
    {: list.add(d); RESULT = list; :}
    | declaration:d
    {: RESULT = new ArrayList<VarDecl>(Arrays.asList(d)); :}
    | /* empty */
    {: RESULT = new ArrayList<VarDecl>(); :};

stmt ::= block:b
    {: RESULT = b; :}
    | IDENTIFIER:id ASSIGN expr:e SEMICOLON
    {: RESULT = new AssignStmt(id, e); :}
    | IF LEFT_PAREN expr:cond RIGHT_PAREN stmt:t ELSE stmt:e
    {: RESULT = new IfStmt(cond, t, e); :}
    | IF LEFT_PAREN expr:cond RIGHT_PAREN stmt:t
    {: RESULT = new IfStmt(cond, t, null); :}
    | WHILE LEFT_PAREN expr:cond RIGHT_PAREN stmt:body
    {: RESULT = new LoopStmt(cond, body); :}
    | RETURN expr:e SEMICOLON
    {: RESULT = new ReturnStmt(e); :};

block ::= LEFT_BRACE declarations:decls stmts:s RIGHT_BRACE
    {: RESULT = new BlockStmt(decls, s); :};

declarations ::= declarations:list declaration:d SEMICOLON
    {: list.add(d); RESULT = list; :}
    | /* empty */
    {: RESULT = new ArrayList<VarDecl>(); :};

declaration ::= type:t IDENTIFIER:id
    {: RESULT = new VarDecl(id, t); :};

type ::= INT {: RESULT = Type.INTEGER; :}
    | BOOLEAN {: RESULT = Type.BOOLEAN; :};

stmts ::= stmts:list stmt:s
    {: list.add(s); RESULT = list; :}
    | /* empty */
    {: RESULT = new ArrayList<Stmt>(); :};

expr ::= expr:e1 PLUS expr:e2      {: RESULT = new BinaryExpr(e1, Operator.ADD, e2); :}
    | expr:e1 MINUS expr:e2     {: RESULT = new BinaryExpr(e1, Operator.SUB, e2); :}
    | expr:e1 STAR expr:e2      {: RESULT = new BinaryExpr(e1, Operator.MUL, e2); :}
    | expr:e1 SLASH expr:e2     {: RESULT = new BinaryExpr(e1, Operator.DIV, e2); :}
    | expr:e1 EQ expr:e2        {: RESULT = new BinaryExpr(e1, Operator.EQ, e2); :}
    | expr:e1 LT expr:e2        {: RESULT = new BinaryExpr(e1, Operator.LT, e2); :}
    | expr:e1 GT expr:e2        {: RESULT = new BinaryExpr(e1, Operator.GT, e2); :}
    | simple_expr:se            {: RESULT = se; :};

simple_expr ::= INTEGER_LIT:i     {: RESULT = new IntLiteral(i); :}
    | TRUE                      {: RESULT = new BoolLiteral(true); :}
    | FALSE                     {: RESULT = new BoolLiteral(false); :}
    | IDENTIFIER:id             {: RESULT = new IdExpr(id); :}
    | IDENTIFIER:name LEFT_PAREN args:a RIGHT_PAREN
    {: RESULT = new FuncCall(name, a); :}
    | LEFT_PAREN expr:e RIGHT_PAREN {: RESULT = e; :};

args ::= args:list COMMA expr:e
    {: list.add(e); RESULT = list; :}
    | expr:e
    {: RESULT = new ArrayList<Expr>(Arrays.asList(e)); :}
    | /* empty */
    {: RESULT = new ArrayList<Expr>(); :};
